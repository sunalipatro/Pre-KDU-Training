export type TagNode = import("../../types").TagNode;
export type ScriptTagNode = import("../../types").ScriptTagNode;
export type StyleTagNode = import("../../types").StyleTagNode;
export type AttributeNode = import("../../types").AttributeNode;
export type AnyNode = import("../../types").AnyNode;
export type TextNode = import("../../types").TextNode;
export type CommentContentNode = import("../../types").CommentContentNode;
export type LineNode = import("../../types").LineNode;
export type BaseNode = import("../../types").BaseNode;
export type Location = import("../../types").Location;
/**
 * @param {TagNode | ScriptTagNode | StyleTagNode} node
 * @param {string} key
 * @returns {AttributeNode | undefined}
 */
declare function findAttr(node: import("../../types").ScriptTagNode | import("../../types").TagNode | import("../../types").StyleTagNode, key: string): import("../../types").AttributeNode | undefined;
/**
 * Checks whether a node's all tokens are on the same line or not.
 * @param {AnyNode} node A node to check
 * @returns {boolean} `true` if a node's tokens are on the same line, otherwise `false`.
 */
declare function isNodeTokensOnSameLine(node: import("../../types").AnyNode): boolean;
/**
 *
 * @param {TextNode | CommentContentNode} node
 * @returns {LineNode[]}
 */
declare function splitToLineNodes(node: import("../../types").TextNode | import("../../types").CommentContentNode): import("../../types").LineNode[];
/**
 * Get location between two nodes.
 * @param {BaseNode} before A node placed in before
 * @param {BaseNode} after A node placed in after
 * @returns {Location} location between two nodes.
 */
declare function getLocBetween(before: import("../../types").BaseNode, after: import("../../types").BaseNode): import("eslint").AST.SourceLocation;
export {};
//# sourceMappingURL=node.d.ts.map